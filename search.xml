<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>无产阶级如何解放获得彻底的解放</title>
    <url>/web-site-article/2022/11/25/Politics/%E6%97%A0%E4%BA%A7%E9%98%B6%E7%BA%A7%E5%A6%82%E4%BD%95%E8%A7%A3%E6%94%BE%E8%8E%B7%E5%8F%96%E8%A7%A3%E6%94%BE/</url>
    <content><![CDATA[<h2 id="无产阶级解放">无产阶级解放</h2>
<h2 id="不要停留在性别认同">不要停留在性别认同</h2>
<h2 id="自由的深渊">自由的深渊</h2>
<p>现代化的个人，要么超脱不了他者对他的框架，按部就班的过着别人给你设计的生活。要么不认同他者对他设定的框架，转向自己给自己设定的框架以达到满足，认为这是一种自由，是一种解放。事实真是如此嘛？第二种较第一种看似有多高明，其实也不然。这种幻想自己能从群里中"独立"实现的个人的自由都不是自由，那么真正的自由是什么呢？</p>
]]></content>
      <categories>
        <category>政治</category>
      </categories>
      <tags>
        <tag>马克思主义</tag>
        <tag>政治</tag>
        <tag>无产阶级</tag>
      </tags>
  </entry>
  <entry>
    <title>意识形态的崇高客体</title>
    <url>/web-site-article/2022/11/28/%E6%84%8F%E8%AF%86%E5%BD%A2%E6%80%81%E7%9A%84%E5%B4%87%E9%AB%98%E5%AE%A2%E4%BD%93/</url>
    <content><![CDATA[<h2 id="征兆">征兆</h2>
<h2 id="大他者的匮乏">大他者的匮乏</h2>
<h2 id="主体">主体</h2>
]]></content>
  </entry>
  <entry>
    <title>自由的深渊</title>
    <url>/web-site-article/2022/11/28/%E8%87%AA%E7%94%B1%E7%9A%84%E6%B7%B1%E6%B8%8A/</url>
    <content><![CDATA[<h2 id="主人是什么">主人是什么？</h2>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法</title>
    <url>/web-site-article/2022/11/26/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<h3 id="何为语法">何为语法</h3>
<h2 id="名词">名词</h2>
<h3 id="分类">分类</h3>
<p>一般来讲，英语中的名词通常分为两大类：专有名词（proper
noun）和普通名词（common noun）。</p>
<p><img
src="https://cdn.staticaly.com/gh/abottleofmilk/CDN@master/img/20221126142923.png" /></p>
<h3 id="名词短语">名词短语</h3>
<p>英语是一种拼音文字，和其他拼音文字一样，<strong>用词尾的变化来表示单、复数</strong>。不仅如此，在名词短语的开头，还有一些符号来配合标示该名词的范围，这种符号在语言学上称为“限定词”(Determiners)。它与词尾的单复数符号互相呼应，共同
determine 名词的范围。冠词就是限定词 (Determiners) 之中的一种。</p>
<h3 id="所有格">所有格</h3>
]]></content>
      <categories>
        <category>语言</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>大话移动通信</title>
    <url>/web-site-article/2022/11/26/%E5%A4%A7%E8%AF%9D%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>大话通信2</title>
    <url>/web-site-article/2022/11/26/%E5%A4%A7%E8%AF%9D%E9%80%9A%E4%BF%A12/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust</title>
    <url>/web-site-article/2022/11/26/Rust/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>后端</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV</title>
    <url>/web-site-article/2022/11/26/OpenCV/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>Scipy</title>
    <url>/web-site-article/2022/11/26/Scipy/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Matplotlib</title>
    <url>/web-site-article/2022/11/26/Matplotlib/</url>
    <content><![CDATA[<ul>
<li>Figure：指整个图形，您可以把它理解成一张画布，它包括了所有的元素，比如标题、轴线</li>
<li>Axes：绘制 2D 图像的实际区域，也称为轴域区，或者绘图区；</li>
<li>Axis：指坐标系中的垂直轴与水平轴，包含轴的长度大小（图中轴长为
7）、轴标签（指 x 轴，y轴）和刻度标签；</li>
<li>Artist：您在画布上看到的所有元素都属于 Artist
对象，比如文本对象（title、xlabel、ylabel）、Line2D
对象（用于绘制2D图像）等。</li>
</ul>
<h2 id="axes">axes</h2>
<h2 id="子图">子图</h2>
<ul>
<li>subplot()
函数，它可以均等地划分画布，如果新建的子图与现有的子图重叠，那么重叠部分的子图将会被自动删除，因为它们不可以共享绘图区域。</li>
<li>subplots() 既创建了一个包含子图区域的画布，又创建了一个 figure
图形对象，而 subplot() 只是创建一个包含子图区域的画布。</li>
<li>subplot2gird()
函数以非等分的形式对画布进行切分，并按照绘图区域的大小来展示最终绘图结果。</li>
</ul>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas</title>
    <url>/web-site-article/2022/11/26/Pandas/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy</title>
    <url>/web-site-article/2022/11/26/Numpy/</url>
    <content><![CDATA[<h3 id="数组的创建">数组的创建</h3>
<p><img
src="https://cdn.staticaly.com/gh/abottleofmilk/CDN@master/img/20221126124056.png" /></p>
<h3 id="数组对象ndarray的常用属性">数组对象ndarray的常用属性</h3>
<p><img
src="https://cdn.staticaly.com/gh/abottleofmilk/CDN@master/img/20221126124151.png" /></p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Sigil_User_Guide</title>
    <url>/web-site-article/2022/11/25/Sigil-user-guide/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<h3 id="环境">环境</h3>
<p>操作系统版本Win11 22H2(OS内部版本 22621.819)</p>
<p>软件版本为1.9.20</p>
<figure>
<img
src="https://cdn.staticaly.com/gh/abottleofmilk/CDN@master/img/image-20221125215511085.png"
alt="image-20221125215511085" />
<figcaption aria-hidden="true">image-20221125215511085</figcaption>
</figure>
<h3 id="安装">安装</h3>
<h3 id="一些基本概念">一些基本概念</h3>
<ul>
<li>OPF（开放打包格式）： EPUB
文件如何相互关联，元数据详细信息(content.opf)。</li>
<li>OPS（开放出版结构）：描述 EPUB 文件中所有内容的关键规范。</li>
<li>OCF（OEBPS 容器格式）：如何将文件打包成.epub文件。</li>
</ul>
<h2 id="基础">基础</h2>
<h3 id="一般的操作流程">一般的操作流程</h3>
<h3 id="编辑器">编辑器</h3>
<ul>
<li>如果在外部程序中编辑文件时在 Sigil
中更改文件，则可能会丢失数据。</li>
<li>使用外部编辑器操作完保存后，再在sigil中编辑。</li>
</ul>
<h3 id="自定义用户界面">自定义用户界面</h3>
<p>要将工具栏移动到其他位置，请将光标悬停在工具栏左侧的抓取栏上。当您这样做时，将出现一个移动光标。左右移动控制大小，直接拖动移动到其他位置。</p>
<figure>
<img
src="https://cdn.staticaly.com/gh/abottleofmilk/CDN@master/img/image-20221125222320730.png"
alt="image-20221125222320730" />
<figcaption aria-hidden="true">image-20221125222320730</figcaption>
</figure>
<p>如果您使工具栏小于将显示所有图标的大小，则工具栏右侧将出现一个箭头。当您单击该箭头时，将出现一个子菜单，允许访问工具栏中的所有按钮。</p>
<figure>
<img
src="https://cdn.staticaly.com/gh/abottleofmilk/CDN@master/img/image-20221125222247724.png"
alt="image-20221125222247724" />
<figcaption aria-hidden="true">image-20221125222247724</figcaption>
</figure>
<p>面板同样可以拖动，拖到你想放置的位置，松开鼠标即可。自定义图标可以控制其样式和大小。</p>
<h3 id="导入文件">导入文件</h3>
<h4 id="文本文件">文本文件</h4>
<p>文本文件不是理想的来源，但它们仍然比某些格式更好，因为它们具有更少的不必要的HTML
标记。如果您对其他格式有很多问题，它们可能值得使用。有时向干净的文档添加样式比尝试清理转换后的文件更快。</p>
<h2 id="高级技巧">高级技巧</h2>
<h3 id="插件">插件</h3>
<p>支持 Python 插件，允许用户自定义 Sigil
的使用方式并将其集成到自己的工作流程中，并独立于 Sigil
添加他们需要或想要的工具。可以下载并安装这些插件以添加对 Sigil
的扩展支持。这些插件包括
epubcheck、Access‑Aide、KindleImport、Kindlegen、FlightCrew、ePub3‑itizer、DOCX
Import 插件等。Sigil 嵌入了自己的 Python 解释器（在撰写本文时为
v3.9.9，以支持基于 Python 3 的插件）。</p>
<h3 id="自动化列表">自动化列表</h3>
<h2 id="其他工具">其他工具</h2>
<h3 id="可能有用的网址">可能有用的网址</h3>
<p><a href="https://www.epubble.com/word-to-epub-tutorial/">Word to ePub
Tutorial | ePubble</a></p>
<p><a
href="https://justpublishingadvice.com/how-a-copywriter-would-write-a-book-description/">Writing
A Book Description By Thinking Like A Copywriter
(justpublishingadvice.com)</a></p>
<p><a href="https://www.mobileread.com/">MobileRead Forums</a></p>
<p><a
href="https://www.mobileread.com/forums/showthread.php?t=247431">Sigil
Plugin Index - MobileRead Forums</a></p>
<h3 id="可能有用的工具">可能有用的工具</h3>
<table>
<thead>
<tr class="header">
<th>名称</th>
<th>简单描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Word to ePub Converter</td>
<td>word转PDF工具 windows</td>
</tr>
<tr class="even">
<td>The Document Converter</td>
<td>word转PDF工具 apple</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="参考">参考</h2>
<ol type="1">
<li><a href="https://sigil-ebook.com/sigil/guide/">Sigil User
Guide</a></li>
<li>[Epub指南--从入门到放弃|<code>赤霓</code>编著]</li>
<li><a
href="https://github.com/Sigil-Ebook/Sigil/blob/master/docs/Sigil_Plugin_Framework_rev14.epub">Sigil_Plugin_Framework_rev14.epub</a></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>近代哲学史-谢林</title>
    <url>/web-site-article/2022/11/25/%E8%BF%91%E4%BB%A3%E5%93%B2%E5%AD%A6%E5%8F%B2-%E8%B0%A2%E6%9E%97/</url>
    <content><![CDATA[<h2 id="译者前言">译者前言</h2>
<p>谢林的后期哲学在形态上表现为“神话哲学”和“天启哲学”，而在内容实质上则是表现为“否定哲学”和“肯定哲学”。这里有必要指出，晚年谢林并不是像很多人误解的那样，以一种非此即彼的态度来对待“否定哲学”和“肯定哲学”，仿佛他的宗旨就在于贬低前者而抬高后者。因为真正说来，这两种哲学都是谢林的后期哲学体系的同等重要的组成部分，二者的区分与柏拉图的本原学说的精神完全一致，即分别代表着“<strong>走向本原的道路</strong>”和“<strong>从本原出发的道路</strong>”。从哲学思考的本性来说，“走向本原的道路”或“否定哲学”必然先行于“从本原出发的道路”或“肯定哲学”，因此前者在某种意义上乃是后者的一个导论。另一方面，为了理解把握谢林的由“否定哲学”和“肯定哲学”组成的后期哲学体系，这本身又需要一个导论，而在谢林看来，对于哲学史的回顾就是这个意义上的最好的一个导论。</p>
<p>哲学史是最好的哲学导论——这是谢林和黑格尔的共识。而且谢林比黑格尔更早地实施了这个计划。在这部《近代哲学史》里，谢林以高屋建瓴的方式阐
述了近代哲学从笛卡尔出发直到谢林本人的后期哲学的演进过程，其重点在于考察近代哲学的“主体”“存在”“思维”“经验”“上帝”“自由”“本原”等核心概念在各位哲学家那里的关键意义，并最终揭示出他所强调的“否定哲学”和“肯定哲学”之间的区分和联系。</p>
<h2 id="前言">前言</h2>
<p>基于各种理由，人们可以发现，对于早先的各种体系进行一番回顾——或至少把这种回顾当作是哲学导论自身的一个附属品——乃是一个合适的做法。科学也是时代的一个作品，并且是在一个持续的发展过程中得到理解把握。任何一个人，如果他相信自己有能力帮助科学迈出或大或小的一个步伐，那么他会很自然地想要揭示出他和之前发生的事情的关系，以便通过这个方式清楚地表明，他是在发展过程或停滞状态的哪一个阶段接手科学，并且打算帮助科学达到随后的哪一个目标。如果他表明，经过从一个层次到另一个层次的发展，那个最高目标至今仍然处于迷失的状态，那么他将会在更高的程度上激励人们参与到他的研究活动之中。通过这个方式，哲学里面的初学者虽然暂时只是获得一些历史知识，但已经接触到了哲学的对象，尤其是近几百年来那些伟大的哲学家所研究的对象。最终说来，<strong>如果人们要赏识真理和评判真理，那么他们也必须要认识到什么是谬误，就此而言，哲学史的阐述就是一种最好的和最温和的方式，向初学者指出那些应当得到纠正的谬误</strong>。再者，如果这里的工作不是仅仅涉及处理具体材料的新方法和新观点，而是涉及“哲学”这一概念自身所蕴含着的变化，那么上述所有理由的分量还会加重。在这种情况下，我们希望表明，虽然“哲学”概念自在地或原本就具有真理，但它同时也是早先各种失败尝试的一个自然而然的、历史的结果，也就是说，这个
概念不再是一个单纯的普遍者，而恰恰是这个 时代的一个必然的结局。</p>
<h2 id="笛卡尔">笛卡尔</h2>
<p>尽管他曾经出于各种理由怀疑其他事物，但就他思考着
而言，这些理由里面没有一个 能促使他去怀疑他自己
。他说，不管我是清醒的还是在做梦，我毕竟思考着
、存在着，即使我在一切别的事情上面都有犯错，但那个犯错的我毕竟存在着
，eram quia
errabam［我犯错，所以我存在］，即使我可以设想，自然的创造者无比强大，他也不可能在这件事情上面欺骗我，因为我必须存在着
，才有可能被欺骗。</p>
<p>我处于人们所称的“思维”这一特定的样式之下，而这个样式仅仅是存在的另一个
样式，正如身体的存在的样式在于填充
空间，亦即把其他身体从它所占据的那个空间那里排挤开。因此那蕴含在cogito［我思考］之内的sum［我存在］并不是意味着“我无条件地存在着”，而是仅仅意味着“我以某种方式
存在着”，也就是说，作为思考者，在这个样式（即人们所称的“思维”）之下存在着。<strong>就此而言，Ergo
sum［因此我存在］也不可能意味着“我以无条件的方式存在着”，而只能意味着“我以某种方式存在着”</strong>。</p>
<p>培根和笛卡尔都反对经院哲学，都在追求一种实实在在的
哲学。只有当涉及那个最高的
概念的时候，双方才决定性地分道扬镳；一方面，笛卡尔希望通过一个先天的论证表明，那个概念独立于一切经验，因此也独立于他自己的
出发点（即“我思考
”这一直接的事实），于是他成为先天哲学或唯理—先天哲学的鼻祖，另一方面，培根无疑认为，最高者也是一种经验性的东西。</p>
<p>“我思考”这个宣言已经预设了两个东西：1）一个在我之内进行思考的东西，比如现在正进行着怀疑的东西；2）一个反思着这个思考或怀疑的东西；只有当后者
认识到前者与它是同一的，我才说：“我思考。”就此而言，“我思考”真正说来根本不是某种直接的东西，它只有通过一种指向我之内的思考的反思才产生出来，而我之内的思考又是独立于那个反思着它的东西而进行的，因为通常说来，我用不着告诉我自己“我在思考”这件事
，用不着反过来思考这个思考本身，就已经在进行思考，甚至可以说，真正的思考必然是客观地独立于那个对其进行反思的主体，换言之，主体愈是不怎么介入思维，思维就愈是真实。</p>
<p>也就是说，因为表象自身并不提供任何担保，所以笛卡尔需要一个担保人
来保障他关于外物的表象是真的——他在这里尝试从主观走向客观，尝试一个过渡（μετάβασις）——于是他在上帝那里找到了担保人，既然如此，上帝的存在就必须首先得到证明。
## 斯宾诺莎</p>
<h2 id="莱布尼茨">莱布尼茨</h2>
<h2 id="沃尔夫">沃尔夫</h2>
<p>我曾经认为，出于各种理由，我在这里必须更加具体地阐述当时的那种形而上学。原因在于：1）真正说来，它毕竟是当时唯一发挥作用、得到公开的容忍和接受的形而上学：无论是笛卡尔还是斯宾诺莎的哲学，甚至是莱布尼茨哲学的真正思辨因素，都未曾得到学院派的接纳；2）重要的是，我们应当知道，一种完全
主观的、亦即始终位于对象之外
的辩证法能够做什么，就此而言，如果我们把这种形而上学当作一种更高的哲学的预习
，在大学里面讲授它，那么这始终是一件有益的事情。尽管我们可以在根本上仅仅把它看作是一种单纯反思性的、主观理性主义的哲学，但正因如此，它同时也容许人们具有某种思想自由
或使用知性的自由
，而既然这个类型的哲学思考是唯一适合于广大民众并且容易被他们接受的，那么它还是能够带来许多助益。因为广大民众在进行哲学思考的时候，不是想要纠正自己的观点，而是想要让自己满足于他们偶然接受的教育；他们不希望看到这样的事情发生，即他们通过教育而建立起来的思想大厦需要一种根本上的修正和重建，于是每一个人都认为自己先天地具有一个理性，这个理性赋予他权利，去预先规定他所愿意认可或不愿意认可的东西——也就是说，广大民众的最终目的，无非就是从他们的
立场出发，同时又不必拘泥于这个立场，仅仅通过一些合理的言论或讨论来解释哲学的那些伟大对象。</p>
<p>学院派形而上学从一开始就纠缠于经院哲学的基本格局和烦琐辞藻，因此随着时间流逝，它越来越过渡到一种单纯反思性的哲学。在一个逐步激发出越来越多的活力的时代里，人们很快注意到了事情
的关键之所在（即那种形而上学不是一种科学的哲学，而是一种单纯反思性的哲学），因此最终说来，每一个人都有权利（或认为自己有权利）进行单纯的反思，因为这种反思只需要一个东西，即每一个人赋予自己的那个普遍理性，但与此同时，却没有人认为，必须通过行为才能证明他确实具有那个理性。在这种情况下，学院派形而上学必然逐渐转变为一类没有形式的哲学，即一种纯粹的通俗哲学，最终陷入到一种彻底的群龙无首的局面。一个鼓吹所谓的独立思考
的时代开始了，然而“独立思考”看起来只不过是一个重复啰唆的说法，因为不言而喻，每一个思考者都必须独立
思考，没有谁能够代替别人去思考，正如没有谁能够代替别人去睡觉或消化食物一样。人们的看法是，借助那个普遍理性，每一个人都已经获得了完整的装备，能够对于哲学的一切对象形成一些合理的观念；人们宣称，每一个人都必须建立他自己的体系，至于一种要求具有客观有效性的哲学，充其量只适合在学校里面讲授，用来激励那些不谙世事的青年，但是生活和经验才是一切，如此等等。当然，从另一方面来看，重视经验也为哲学带来了有益的影响，因为这促进了经验心理学的产生和改造。尽管经验心理学直到如今都还缺乏一个真正的科学的
奠基，但是它毕竟给人类精神开启了一个关于它自身的崭新领域，尤其是那个极为有趣的、介于生理因素和心理因素之间的领域。
## 康德</p>
<h2 id="费希特">费希特</h2>
<h2 id="先验唯心论体系">先验唯心论体系</h2>
<h2 id="自然哲学">自然哲学</h2>
<h2 id="黑格尔">黑格尔</h2>
<h2 id="谢林">谢林</h2>
<h2 id="论哲学里面的民族对立">论哲学里面的民族对立</h2>
<h2
id="为维克多库桑先生哲学著作所作序">为维克多·库桑先生哲学著作所作序</h2>
<h2 id="哲学经验论概要-1834">哲学经验论概要 1834</h2>
<h2 id="一些总结">一些总结</h2>
<p>笛卡尔的我思并不是无条件的存在的，</p>
<h2 id="参考">参考</h2>
<ol type="1">
<li><a
href="https://www.bilibili.com/video/BV14d4y137dy/?spm_id_from=333.788">哲学导读</a></li>
<li><a
href="https://book.douban.com/subject/26694273/">近代哲学史</a></li>
</ol>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学</tag>
        <tag>哲学史</tag>
        <tag>发展史</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化库</title>
    <url>/web-site-article/2022/11/25/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BA%93/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>数字图像处理</title>
    <url>/web-site-article/2022/11/25/science/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="绪论">绪论</h2>
<h3 id="图像的起源">图像的起源</h3>
<p>图像处理技术最早应用于遥感和医学领域。1839年世界上出现的第一张照片和1909年意大利人乘飞机拍摄的第一张照片通常被认为是遥感技术的起源，标志着图像处理技术的兴起。在医学领域中，利用图像进行直观诊断可以追溯到1895年X射线的发现。1895年，德国维尔茨堡大学校长兼物理研究所所长威尔霍姆·康瑞德·伦琴教授（1845—1923年）在从事阴极射线研究时，偶然发现了X射线，他发现X射线可以穿透肌肉照出手骨轮廓。伦琴教授（图1-1（a））为其夫人拍摄的手部图像如图1-1（b）所示，这是第一张具有历史意义的图像，由于这一发现，伦琴教授获得了1901年诺贝尔物理学奖。</p>
<p><img src="https://s2.loli.net/2022/11/25/YhsxOSz83XZq2NL.png" /></p>
<p>数字图像处理的历史可追溯至20世纪20年代。1921年，巴特兰（Bartlane）电缆图像传输系统把横跨大西洋传送一张图像所需要的时间从一个多星期减少到3h。为了用电缆传输图像，首先要进行编码，然后在接收端用特殊的打印设备重现该图像，图1-2（a）就是采用这种方法传送并利用电报打印机通过字符模拟中间色调还原出来的图像。1921年年底，这种打印方法被淘汰，取而代之的是一种基于光学还原的技术，该技术在电报接收端用穿孔纸带打印图像。图1-2（b）是1922年在信号两次穿越大西洋后，从穿孔纸带打印得到的数字图像，它在色调质量和分辨率方面都有明显改进。早期的巴特兰系统可以用5个灰度等级对图像编码，到1929年已增加到15个等级。图1-2（c）就是1929年从伦敦到纽约用15级色调设备通过海底电缆传送的Generals
Pershing和Foch的未经修饰的图像。</p>
<h3 id="图像的基本概念">图像的基本概念</h3>
<p>图像是对物体的表达、表象、模仿，是一个生动的视觉描述，是为了表达其他事物而引入的。严格地说，图像是用各种观测系统以不同形式和手段观测客观世界而获得的，可以直接或间接作用于人眼并进而产生视知觉的实体。一张图像可以定义为一个二维函数f（x，y），其中，x和y为2D空间XY中一个坐标点的位置；函数值f为图像在点（x，y）处具有的某种性质F的值，如灰度图像的F表示灰度值，它通常对应客观景物被观察到的亮度；二值图像的F仅取两个灰度值等。f、x和y的值都是连续的，即可以是任意实数。</p>
<p>把连续的图像f（x，y）在2D空间XY和性质空间F都离散化，这种离散化了的图像称为数字图像，可以用I（r，c）来表示，其中，（r，c）为离散化后的（x，y），r为图像的行（row），c为图像的列（column）；函数值I表示离散化后的函数值f；I、r和c的值都是整数。一般地，用f（x，y）表示数字图像，f、x和y都在整数集合中取值。一般地，用f（x，y）表示数字图像，f、x和y都在整数集合中取值。</p>
<h4 id="图像的表达">图像的表达</h4>
<p>数字图像一般用二维函数f（x，y）表示，通常可表示为如式（1-1）所示的R×C矩阵的形式，其中，R为图像的行数，C为图像的列数。</p>
<p>数字图像的表示方式包括<strong>点方式、块方式和值方式</strong>，如图所示。其中，（a）为点方式，指用像素点表示像素，得到图像平面上的离散点，该方式的优点是简单清晰，缺点是仅能表示像素的有无，不能表示像素的灰度值。（b）为块方式，指用颜色深浅不同的像素区域块表示像素，该方式的优点是可视性好，缺点是仅能表示灰度值不同的少量像素。（c）为值方式，指用像素灰度值表示像素，该方式的优点是可以准确表示任意灰度值的像素，缺点是可视性稍差。</p>
<p><img src="https://s2.loli.net/2022/11/25/vpVg3ZdluM4JAfX.png" /></p>
<p><strong>数字图像在显示时，坐标系统包括屏幕显示方式和图像计算方式两种</strong>，如图1-8所示。（a）为屏幕显示方式，所用的坐标系通常在屏幕显示中采用（屏幕扫描是从左到右、从上到下进行的），它的坐标原点在图像的左上角，纵轴表示图像的行，横轴表示图像的列。I（r，c）既可表示整幅图像，也可表示在r行和c列交点处的图像值。（b）为图像计算方式，所用的坐标系通常在图像计算中采用（与常用的笛卡儿坐标系相同），它的坐标原点在图像的右下角，横轴表示X轴，纵轴表示Y轴。f（x，y）既可表示整幅图像，也可表示在（x，y）坐标处的像素值。</p>
<p><img src="https://s2.loli.net/2022/11/25/dkSsIJ8K4w9n5TB.png" /></p>
<h3 id="图像处理技术分类">图像处理技术分类</h3>
<p>按照图像类型的不同，图像处理技术可以分为<strong>模拟图像处理和数字图像处理</strong>两大类。</p>
<p>1．模拟图像处理模拟图像处理包括光学处理（通常利用透镜实现）和电子处理，例如，照相、遥感图像处理、电视信号处理等。电视图像是模拟信号处理的典型例子，它处理的是活动图像，每秒25帧。模拟图像处理的优点是速度快，一般为实时处理，理论上可达到光速，可实现并行处理；缺点是精度较差，灵活性差，很难有非线性处理能力和判断能力。</p>
<p>2．数字图像处理数字图像处理（Digital Image
Processing）一般采用计算机或专用硬件进行，也称为计算机图像处理（Computer
Image
Processing）。数字图像处理的优点是处理精度高，处理内容丰富，可进行复杂的非线性处理；缺点是处理速度较慢，尤其针对大数据量的复杂处理更是如此。</p>
<h2 id="颜色">颜色</h2>
<h3 id="颜色马蹄图">颜色马蹄图</h3>
<p>把人眼可见的所有光的颜色信息和明度信息通过一定的数学变化映射到一个平面上，就得到了一个色域马蹄图。它代表了人眼可以识别的所有颜色。这个颜色空间被称为CIE色彩空间。现在显示器的显示是依赖红绿蓝三个颜色去混合，所以一台显示器显示颜色的极限就是红绿蓝各自亮度最大的连线组成的三角形范围也就是<strong>色域</strong>。各行各业有不同的标准，在CIE颜色范围覆盖内圈划出一段空间作为标尺存储颜色信息的时候根据其存储，显示根据其显示。这就是<strong>色彩空间</strong>的概念。</p>
<p><img src="https://s2.loli.net/2022/11/25/NfDJy79Kd4mu6LO.png" style="zoom:50%;" /></p>
<p>显示器显示不出来的颜色就会按照一定的映射去强行让它显示。屏幕上的马蹄图已经不是原来的颜色了。<strong>色准</strong>指的就是显示器在色域覆盖范围内显示颜色的准确度。衡量标准叫∆E值。校色仪生产ICC文件来校准颜色。<strong>色深</strong>：颜色在过渡时候的能表现的阶梯数，如有的RGB每个是256，有的是1024。越多说明过度是时候颜色渐变的越舒适。</p>
<p><img src="https://s2.loli.net/2022/11/25/A7Q6PXBJVHp4ML1.png" /></p>
<h2 id="图像与视觉系统">图像与视觉系统</h2>
<h3 id="图形类型">图形类型</h3>
<p>图像类型指图像的<strong>颜色深度</strong>与<strong>颜色数</strong>之间的关系。颜色深度指图像每一个像素的颜色值所占用的二进制位数。例如，颜色深度为8，表示每一个像素的颜色值占8个二进制位，即1字节。颜色数指图像每一个像素所有可能的颜色值的个数，即图像颜色表的表项数，也就是通常所说的幅度分辨率。例如，颜色深度为8的图像的颜色数为28=256。</p>
<h4 id="二值图像">二值图像</h4>
<p>二值图像也称单色图像或1位图像，即颜色深度为1的图像。颜色深度为1表示每个像素点仅占1个二进制位，每个像素点的颜色只可能取两种颜色之一，通常，这两种颜色取黑色或白色，0表示黑色，1表示白色。</p>
<p><img src="https://s2.loli.net/2022/11/25/ipoGVqPDAczZKx6.png" /></p>
<h4 id="灰度图像">灰度图像</h4>
<p>0表示黑色，255表示白色，介于黑色和白色之间的不同程度的灰色由0～255的不同数值来表示。</p>
<p><img src="https://s2.loli.net/2022/11/25/xA1zup5P4ZWCOlm.png" /></p>
<h4 id="真彩色图像">真彩色图像</h4>
<p>真彩色图像每一个像素由R、G、B三个分量组成，每一个像素点的每一个分量的取值可能是0～255中的某一个值，三个分量的值共同构成该像素点的颜色值。因此，真彩色图像具有最丰富的颜色，其颜色数可达224=16777216种。</p>
<p><img src="https://s2.loli.net/2022/11/25/b7HR1pMc9P2YOvS.png" /></p>
<h4 id="伪彩色图像">伪彩色图像</h4>
<p>伪彩色（pseudo
color）图像的每个像素的颜色不是由每个基色分量的数值直接决定，而是把像素值当作颜色查找表的表项入口地址，去查找一个显示图像时使用的（R，G，B）强度值，用查找出的（R，G，B）强度值产生的彩色作为当前像素点的颜色。</p>
<p>伪彩色图像通常包括256色彩色图像和16色彩色图像。256色彩色图像的每个像素由8个二进制位组成，取值范围为0～255，可以表示256种不同的彩色，能够达到照片效果，比较真实。16色彩色图像的每个像素由4个二进制位组成，取值范围为0～15，可以表示16种不同的彩色，通常用于对遥感图像的灰度赋予不同的假色彩以改善视觉效果。</p>
<p><img src="https://s2.loli.net/2022/11/25/GhcBkdL2xZyQ6vH.png" /></p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>数字图形</tag>
      </tags>
  </entry>
  <entry>
    <title>android</title>
    <url>/web-site-article/2022/11/25/other/android/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>bash</title>
    <url>/web-site-article/2022/11/25/tutorial/bash/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>tauri</title>
    <url>/web-site-article/2022/11/25/technology/tauri/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>黑格尔-牛津通识读本</title>
    <url>/web-site-article/2022/11/24/reading/%E9%BB%91%E6%A0%BC%E5%B0%94/</url>
    <content><![CDATA[<h2 id="第一章-黑格尔的时代与生平">第一章 黑格尔的时代与生平</h2>
<h2 id="第二章-有目的的历史">第二章 有目的的历史</h2>
<h2 id="第三章-自由与共同体">第三章 自由与共同体</h2>
<h2 id="第四章-精神的漫长历程">第四章 精神的漫长历程</h2>
<h2 id="第五章-逻辑与辩证法">第五章 逻辑与辩证法</h2>
<h2 id="第六章-余波">第六章 余波</h2>
<p>黑格尔去世后，那些自视为其追随者的人分成了两个阵营。正统黑格尔派或黑格尔右派遵循其晚年风格，把他的宗教观点与基督教新教调和起来，并且接受《法哲学原理》中对普鲁士国家总体上正面的看法。这个保守的黑格尔主义学派没有产生什么重要的思想家，在柏林以半官方哲学的地位维持几年之后便迅速衰落，以致到了19世纪60年代，黑格尔哲学在德国已经完全过时。另一个阵营则非常不同，它由一群思想激进的青年人组成。他们对黑格尔的态度就像黑格尔对康德的态度。就像黑格尔一直认为康德的自在之物学说未能完成其哲学的根本含义，黑格尔的这些弟子也认为，黑格尔接受基督教、普鲁士国家和他那个时代的一般状况，也是未能完成其哲学的根本含义。这群人被称为青年黑格尔派或黑格尔左派，未来取决于他们。</p>
<p>青年黑格尔派认为黑格尔的哲学在要求一个更美好的世界。这是一个合理组织起来的世界，一个真正自由的世界，个人与社会之间的对立将被克服。简而言之，这个世界可以反映出人类精神及其理性力量的绝对至上。在青年黑格尔派看来，这个更美好的世界并不单纯是一种幻想出来的乌托邦理想，而是黑格尔体系的历史与哲学论证的最终完成。它是一种辩证的必然性，是一个必定会出现的合题，以使他们那个世界中的各种对立因素得以调和。</p>
<p>对于那种认为19世纪30年代的德国已经实现了黑格尔哲学承诺的想法，青年黑格尔派嗤之以鼻，他们着手实现自己的激进看法。首先他们把宗教看成对一个可以使人充分发挥潜力的社会的关键障碍。通过发展《精神现象学》“苦恼意识”一节中的线索，他们指出宗教是一种异化形式。人创造了上帝，然后又想象上帝创造了自己。人把他自身之中所有最好的东西——知识、善和力量——都赋予了他的上帝形象，然后又在他自己创造的这个形象面前顶礼膜拜，而把自己看成无知、有罪和软弱。要使人类恢复其完整力量，只需使他们认识到，人类才真正是神性的最高形态。</p>
<p>为此，两个青年黑格尔派撰写了对19世纪宗教思想有巨大影响的著作。大卫·弗里德里希·施特劳斯写了一本卓越的《耶稣传》。通过把福音书作为历史批判的原始材料，他给后来关于历史上的耶稣的所有研究树立了典范。路德维希·费尔巴哈的《基督教的本质》则把一切传统宗教都说成人把自己的属性投射到另一个领域，遂成为发展一种宗教信仰心理学的第一次现代尝试。早在黑格尔本人的著作在德国以外还几乎不为人所知时，由玛丽安·埃文斯（她还协助翻译了施特劳斯的著作，以笔名乔治·艾略特广为人知）译成英文的这部著作已经有了广泛的世界影响。接着，青年黑格尔派越过了宗教。费尔巴哈以更为激进的方式，用黑格尔的思想来反对黑格尔。他指责黑格尔以一种神秘的方式来给出关于世界的真理。黑格尔相信精神是终极实在，所以一直把世界中的不和谐问题看成思想领域中的一个问题，因此认为哲学能够解决它。现在费尔巴哈把黑格尔颠倒过来。不能由思想推导出存在，而应由存在推导出思想。人的真正基础并不在精神，反倒是精神的真正基础在人那里。黑格尔的哲学本身是一种异化形态，因为他把实际的活生生的人的本质当成了某种外在于他们自身的东西——“精神自身”。费尔巴哈说，我们既不需要神学，也不需要哲学，而是需要一种研究现实生活中实际的人的科学。</p>
<p>此时距离青年黑格尔派的著作使黑格尔思想的要素对世界历史产生持久影响已经为期不远了。黑格尔去世后大约六年，卡尔·马克思来到了柏林大学。很快他便结识了青年黑格尔派，并参与了当时流行的宗教批判。当费尔巴哈宣称需要超出思想领域时，马克思热情回应了这一号召。在《1844年经济学哲学手稿》中，马克思称赞了黑格尔《精神现象学》关于异化和劳动重要性的论述，然后发展出了他自己关于资本主义制度下劳动作为主要异化形式的看法。马克思指出，要使人类获得解放，就必须消除异化劳动；而要消除异化劳动，就必须废除私有财产和与之伴随的工资制度：换句话说就是建立共产主义。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器工作原理</title>
    <url>/web-site-article/2022/11/24/front-end/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>如何学习</title>
    <url>/web-site-article/2022/11/24/documents/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>java指南</title>
    <url>/web-site-article/2022/11/24/back-end/java%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>工业革命</title>
    <url>/web-site-article/2022/11/24/Histories/%E5%B7%A5%E4%B8%9A%E9%9D%A9%E5%91%BD/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>历史</category>
      </categories>
      <tags>
        <tag>历史</tag>
        <tag>工业革命</tag>
      </tags>
  </entry>
  <entry>
    <title>全球通识:从史前史到21世纪</title>
    <url>/web-site-article/2022/11/24/Histories/%E5%85%A8%E7%90%83%E9%80%9A%E8%AF%86_%E4%BB%8E%E5%8F%B2%E5%89%8D%E5%8F%B2%E5%88%B021%E4%B8%96%E7%BA%AA/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>历史</category>
      </categories>
      <tags>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title>1844年经济学哲学手稿</title>
    <url>/web-site-article/2022/11/24/Philosophy/1844%E5%B9%B4%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%93%B2%E5%AD%A6%E6%89%8B%E7%A8%BF/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>哲学</category>
        <category>马克思主义</category>
      </categories>
      <tags>
        <tag>哲学</tag>
        <tag>马克思主义</tag>
      </tags>
  </entry>
  <entry>
    <title>否定辩证法</title>
    <url>/web-site-article/2022/11/24/Philosophy/%E5%90%A6%E5%AE%9A%E8%BE%A9%E8%AF%81%E6%B3%95/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>辩证法的历史与逻辑</title>
    <url>/web-site-article/2022/11/24/Philosophy/%E8%BE%A9%E8%AF%81%E6%B3%95%E7%9A%84%E5%8E%86%E5%8F%B2%E4%B8%8E%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>哲学</category>
        <category>辩证法</category>
      </categories>
      <tags>
        <tag>哲学</tag>
        <tag>辩证法</tag>
      </tags>
  </entry>
  <entry>
    <title>导读齐泽克</title>
    <url>/web-site-article/2022/11/24/Philosophy/%E5%AF%BC%E8%AF%BB%E9%BD%90%E6%B3%BD%E5%85%8B/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学</tag>
        <tag>齐泽克</tag>
        <tag>精神分析</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode指南</title>
    <url>/web-site-article/2022/11/24/other/vscode%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>javaScript入门指南</title>
    <url>/web-site-article/2022/11/24/tutorial/javaScript%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>QT教程</title>
    <url>/web-site-article/2022/11/24/tutorial/QT%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="工具">工具</h2>
<h3 id="qt目录结构">QT目录结构</h3>
<p><img src="https://s2.loli.net/2022/11/25/7E2LJ3jxRqlWgcY.png" style="zoom: 80%;" /></p>
<p>Qt 类库的帮助文件位于 Docs 文件夹里，需要用 Qt Assistant
工具才能查看。QtCreator 是个例外，QtCreator 使用 MSVC2015
编译生成的，所以安装目录里有一个 vcredist 文件夹存储 VC
运行库安装文件。最后的 MaintenanceTool.exe
，对于离线安装包，它只能用于删除软件包，如果 Qt
开发环境是用在线安装方式装的，这个工具还可以管理开发环境组件和升级组件。</p>
<p><img src="https://s2.loli.net/2022/11/25/93YAlISg5hmLOD1.png" style="zoom: 75%;" /></p>
<h3 id="常用工具">常用工具</h3>
<p>在上个世纪八十年代，计算机都是奢侈品，操作系统里最著名的是 Unix
家族， 当时还没有 Windows、Linux 之类的，Unix
系统都是商业软件，里面的应用软件也是商业软件， 全是封闭的环境。
系统程序员 Richard M. Stallman (RMS) 在此环境下创立了与众不同的 <a
href="https://www.gnu.org/">GNU 项目</a> (GNU's Not Unix) ，
以及推进自由软件发展的 <a href="https://www.fsf.org/">Free Software
Foundation (FSF) 自由软件基金会</a>。 GNU 项目是为了创建自由的类 Unix
系统，也因此开发出来很多开源的系统工具，其中非常著名的就是 <a
href="http://c.biancheng.net/gcc/">GCC</a> （GNU Compiler
Collection，GNU编译器套件）。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>工具</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>gcc</td>
<td>GNU C 语言编译器。</td>
</tr>
<tr class="even">
<td>g++</td>
<td>GNU <a href="http://c.biancheng.net/cplus/">C++</a>
语言编译器。</td>
</tr>
<tr class="odd">
<td>ld</td>
<td>GNU
链接器，将目标文件和库文件链接起来，创建可执行程序和动态链接库。</td>
</tr>
<tr class="even">
<td>ar</td>
<td>生成静态库 .a ，可以编辑和管理静态链接库。</td>
</tr>
<tr class="odd">
<td>make</td>
<td>生成器，可以根据 makefile
文件自动编译链接生成可执行程序或库文件。</td>
</tr>
<tr class="even">
<td>gdb</td>
<td>调试器，用于调试可执行程序。</td>
</tr>
<tr class="odd">
<td>ldd</td>
<td>查看可执行文件依赖的共享库（扩展名 .so，也叫动态链接库）。</td>
</tr>
</tbody>
</table>
<ul>
<li>CMake（Cross platform Make）是一个开源的跨平台自动化构建工具，
可以跨平台地生成各式各样的 makefile 或者 project 文件，
支持利用各种编译工具生成可执行程序或链接库。 CMake 自己不编译程序，
它相当于用自己的构建脚本
CMakeLists.txt，叫各种编译工具集去生成可执行程序或链接库。</li>
<li>原本 GNU 工具只在 Linux/Unix 系统里才有，随着 Windows
系统的广泛使用， 为了在 Windows 系统里可以使用 GNU 工具，诞生了
MinGW（Minimalist GNU for Windows） 项目，利用 MinGW 就可以生成 Windows
里面的 exe 程序和 dll 链接库。</li>
<li>另外提一下，由于 MinGW
本身主要就是编译链接等工具和头文件、库文件，并不包含系统管理、文件操作之类的
Shell 环境， 这对希望用类 Unix 命令的开发者来说还是不够用的。 所以 MinGW
官方又推出了 MSYS（Minimal SYStem），相当于是一个部署在 Windows
系统里面的小型 Unix 系统环境， 移植了很多 Unix/Linux
命令行工具和配置文件等等，是对 MinGW 的扩展。MSYS2 是 MSYS
的衍生版，不仅支持 64 位系统和 32
位系统，还有自己的独特的软件包管理工具，它从 Arch Linux 系统里移植了
pacman 软件管理工具，所以装了 MSYS2 之后，可以直接通过 pacman
来下载安装软件，而且可以自动解决依赖关系、方便系统升级等。装了 MSYS2
之后，不需要自己去下载 MinGW-w64，可以直接用 pacman
命令安装编译链接工具和 git 工具等。</li>
</ul>
<p>Qt 官方的开发环境安装包里有自己专门的开发工具，之前用过 qmake
命令。qmake 是 Qt 开发最核心的工具，既可以生成 Qt 项目文件 .pro
，也可以自动生成项目的 Makefile 文件。</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>工具</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>qmake</td>
<td>核心的项目构建工具，可以生成跨平台的 .pro
项目文件，并能依据不同操作系统和编译工具生成相应的
Makefile，用于构建可执行程序或链接库。</td>
</tr>
<tr class="even">
<td>uic</td>
<td>User Interface Compiler，用户界面编译器，Qt 使用 XML 语法格式的 .ui
文件定义用户界面，uic 根据 .ui 文件生成用于创建用户界面的 C++
代码头文件，比如 ui_*****.h 。</td>
</tr>
<tr class="odd">
<td>moc</td>
<td>Meta-Object Compiler，元对象编译器，moc 处理 C++
头文件的类定义里面的 Q_OBJECT 宏，它会生成源代码文件，比如 moc_*****.cpp
，其中包含相应类的元对象代码，元对象代码主要用于实现 Qt
信号/槽机制、运行时类型定义、动态属性系统。</td>
</tr>
<tr class="even">
<td>rcc</td>
<td>Resource Compiler，资源文件编译器，负责在项目构建过程中编译 .qrc
资源文件，将资源嵌入到最终的 Qt 程序里。</td>
</tr>
<tr class="odd">
<td>qtcreator</td>
<td>集成开发环境，包含项目生成管理、代码编辑、图形界面可视化编辑、
编译生成、程序调试、上下文帮助、版本控制系统集成等众多功能，
还支持手机和嵌入式设备的程序生成部署。</td>
</tr>
<tr class="even">
<td>assistant</td>
<td>Qt 助手，帮助文档浏览查询工具，Qt
库所有模块和开发工具的帮助文档、示例代码等都可以检索到，是 Qt
开发必备神器，也可用于自学 Qt。</td>
</tr>
<tr class="odd">
<td>designer</td>
<td>Qt 设计师，专门用于可视化编辑图形用户界面（所见即所得），生成 .ui
文件用于 Qt 项目。</td>
</tr>
<tr class="even">
<td>linguist</td>
<td>Qt 语言家，代码里用 tr() 宏包裹的就是可翻译的字符串，开发人员可用
lupdate 命令生成项目的待翻译字符串文件 .ts，用 linguist 翻译多国语言 .ts
，翻译完成后用 lrelease 命令生成 .qm
文件，然后就可用于多国语言界面显示。</td>
</tr>
<tr class="odd">
<td>qmlscene</td>
<td>在 Qt 4.x 里是用 qmlviewer 进行 QML 程序的原型设计和测试，Qt 5 用
qmlscene 取代了旧的 qmlviewer。新的 qmlscene 另外还支持 Qt 5 中的新特性
scenegraph 。</td>
</tr>
</tbody>
</table>
<h3 id="术语">术语</h3>
<h4 id="project">Project</h4>
<p>Project
的中文翻译是“项目”或者“工程”，这里的项目是指为实现某个相对独立功能的程序代码合集，这些代码不单单是放在一块，而是有相互之间的关联性，并且有专门负责管理该项目的项目文件，比如：</p>
<ul>
<li>Qt 使用 .pro 文件管理项目；</li>
<li>VC++ 则使用 .vcproj 作为项目文件。</li>
</ul>
<p>集成开发环境通常都是依据项目文件（.pro/.vcproj）管理和构建项目。</p>
<h4 id="makefile">Makefile</h4>
<p>即生成脚本，虽然可以直接调用编译器如 g++
编译程序，但是如果项目里的代码文件变多了，哪些代码文件更新了需要重新编译，哪些代码没有改不需要重新编译等等，靠程序员自己记忆去处理是比较麻烦的事，还有哪些代码需要预处理或是链接哪些库文件，
这些都是繁杂的过程。为了规范程序的编译生成过程，产生了规范化的生成脚本，就是
Makefile，生成器 make 可以依据规范的 Makefile
自动生成目标程序或库文件。</p>
<h4 id="debug-和-release">Debug 和 Release</h4>
<p>Debug 即调试，Release
即发行。代码编写之后，生成的目标程序或库文件通常不会绝对正确，或多或少有些毛病（bug），
因此需要进行纠错调试（Debug）。调试过程中需要源代码和二进制目标程序之间一一对应的关系，
这样才能定位到错误代码，所以 Debug 版本的程序是臃肿而不进行优化的。</p>
<p>与之相对的是 Release
发行版，在纠正了发觉到的错误后，需要发布程序用于实际用途，实际应用时强调运行效率高，减少冗余代码，因此会对二进制程序进行大量优化，提升性能。这样发布的二进制目标程序就是
Release 版。</p>
<h4 id="explicit-linking-和-implicit-linking">Explicit Linking 和
Implicit Linking</h4>
<p>动态链接库通常都有其导出函数列表，
告知其他可执行程序可以使用它的哪些函数。可执行程序使用这些导出函数有两种方式：一是在运行时使用主动加载动态库的函数，Linux
里比如用 dlopen 函数打开并加载动态库，Windows 里一般用 LoadLibrary
打开并加载动态库，只有当程序代码执行到这些函数时，其参数里的动态库才会被加载，这就是显式链接。显式链接方式是在运行时加载动态库，其程序启动时并不检查这些动态库是否存在。</p>
<p>隐式链接是最为常见的，所有的编译环境默认都是采用隐式链接的方式使用动态库。隐式链接会在链接生成可执行程序时就确立依赖关系，在该程序启动时，操作系统自动会检查它依赖的动态库，并一一加载到该程序的内存空间，程序员就不需要操心什么时候加载动态库了。VC
链接器使用的 .lib
文件分两类，一种是完整的静态库，体积比较大，另一种是动态库的导出声明，体积比较小。MinGW
链接器使用的 .a 文件也是类似的，Qt
官方库都是按照动态库发布的，静态库只有自己编译才会有。</p>
<h3 id="控件与事件">控件与事件</h3>
<ul>
<li>QMainWindow
类生成的窗口自带菜单栏、工具栏和状态栏，中央区域还可以添加多个控件，常用来作为应用程序的主窗口；</li>
<li>QDialog
类生成的窗口非常简单，没有菜单栏、工具栏和状态栏，但可以添加多个控件，常用来制作对话框。</li>
<li>实际开发中，制作应用程序的主窗口可以用 QMainWindow 或者
QWdiget；制作一个提示信息的对话框就用 QDialog 或
QWidget；如果暂时无法决定，后续可能作为窗口，也可能作为控件，就选择
QWidget。</li>
</ul>
<p>事件处理函数通常会完成两项任务，分别是：</p>
<ul>
<li>​
修改控件的某些属性，比如当用户按下按钮时，按钮的背景颜色会发生改变，从而提示用户已经成功地按下了按钮；</li>
<li>​ 运用信号和槽机制处理事件。</li>
</ul>
<h3 id="信号和槽">信号和槽</h3>
<p>一个 connect()
函数只能关联一个信号函数和一个槽函数，程序中可以包含多个 connect()
函数，能实现以下几种效果：</p>
<ul>
<li>关联多个信号函数和多个槽函数；</li>
<li>一个信号函数可以关联多个槽函数，当信号发出时，与之关联的槽函数会一个接一个地执行，但它们执行的顺序是随机的，无法人为指定哪个先执行、哪个后执行；</li>
<li>多个信号函数可以关联同一个槽函数，无论哪个信号发出，槽函数都会执行。</li>
</ul>
<h2 id="基础">基础</h2>
<h3 id="qt与其他gui库">QT与其他GUI库</h3>
<p>Windows 下的 GUI 解决方案比较多：</p>
<ul>
<li>基于 <a href="http://c.biancheng.net/cplus/">C++</a> 的有 <a
href="http://c.biancheng.net/qt/">Qt</a>、MFC、WTL、wxWidgets、DirectUI、Htmlayout；</li>
<li>基于 <a href="http://c.biancheng.net/csharp/">C#</a> 的有
WinForm、WPF；</li>
<li>基于 <a href="http://c.biancheng.net/java/">Java</a> 的有 AWT、<a
href="http://c.biancheng.net/swing/">Swing</a>；</li>
<li>基于 Pascal 的 有Delphi；</li>
<li>基于Go语言的有 walk 和 electron；</li>
<li>还有国内初露头角的 aardio；</li>
<li>Visual Basic 曾经很流行，现在逐渐失去了色彩；</li>
<li>如果你有 Web 开发经验，也可以基于 Webkit 或 Chromium
将网页转换为桌面程序。</li>
</ul>
<p><img src="https://s2.loli.net/2022/11/25/kzIwlg5F2KBUOjT.png" alt="image-20221125165119244" style="zoom: 67%;" /></p>
<p>MFC 只能应用在 Windows 平台，而 Qt 是跨平台的，一次编写，到处运行。
另外，Qt 已经封装了底层细节，学习 Qt 将会非常简单；而 MFC 只是给 Windows
API 加了一层包装，不了解 Windows API 也学不好 MFC。Linux 下常用的 GUI
库有基于 C++ 的 Qt、GTK+、wxWidgets，以及基于 Java 的 AWT 和
Swing。其中最著名的就是 Qt 和 GTK+：KDE 桌面系统已经将 Qt 作为默认的 GUI
库，Gnome 桌面系统也将 GTK+ 作为默认的 GUI 库。</p>
<h3 id="qt程序">QT程序</h3>
<p>Qt Creator
可以创建多种项目，在最左侧的列表框中单击“Application”，中间的列表框中列出了可以创建的应用程序的模板，各类应用程序如下：</p>
<ul>
<li>Qt Widgets Application，支持桌面平台的有图形用户界面（Graphic User
Interface，GUI） 界面的应用程序。GUI 的设计完全基于 C++ 语言，采用 Qt
提供的一套 C++ 类库。</li>
<li>Qt Console Application，控制台应用程序，无 GUI 界面，一般用于学习
C/C++ 语言，只需要简单的输入输出操作时可创建此类项目。</li>
<li>Qt Quick Application，创建可部署的 Qt Quick 2 应用程序。Qt Quick 是
Qt 支持的一套 GUI 开发架构，其界面设计采用 QML 语言，程序架构采用 C++
语言。利用 Qt Quick
可以设计非常炫的用户界面，一般用于移动设备或嵌入式设备上无边框的应用程序的设计。</li>
<li>Qt Quick Controls 2 Application，创建基于 Qt Quick Controls 2
组件的可部署的 Qt Quick 2 应用程序。Qt Quick Controls 2 组件只有 Qt 5.7
及以后版本才有。</li>
<li>Qt Canvas 3D Application，创建 Qt Canvas 3D QML 项目，也是基于 QML
语言的界面设计，支持 3D 画布。</li>
</ul>
<p>项目结构：</p>
<ul>
<li>Demo.pro 是项目管理文件，包括一些对项目的设置项。</li>
<li>Headers 分组，该节点下是项目内的所有头文件（.h），图 5
中所示项目有一个头文件 mainwindow.h，是主窗口类的头文件。</li>
<li>Sources 分组：该节点下是项目内的所有 C++源文件（.cpp），图 5
中所示项目有两个 C++ 源文件，mainwindow.cpp 是主窗口类的实现文件，与
mainwindow.h 文件对应。main.cpp 是主函数文件，也是应用程序的入口。</li>
<li>Forms 分组：该节点下是项目内的所有界面文件（.ui）。图 5
中所示项目有一个界面文件mainwindow.ui，是主窗口的界面文件。界面文件是文本文件，使用
XML 语言描述界面的组成。</li>
</ul>
<p><strong>默认情况下，Qt
提供的所有组件（控件、部件）都是隐藏的，不会自动显示</strong>。</p>
<h3 id="布局管理">布局管理</h3>
<p>Qt 共提供了 5 种布局管理器，每种布局管理器对应一个类，分别是
QVBoxLayout（垂直布局）、QHBoxLayout（水平布局）、QGridLayout（网格布局）、QFormLayout（表单布局）和
QStackedLayout（分组布局）。</p>
<p><img src="https://s2.loli.net/2022/11/25/qg8znERj9PoDBIC.png" alt="image-20221125171951969" style="zoom:80%;" /></p>
<h3 id="pro文件详解">pro文件详解</h3>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="header">
<th>配置项</th>
<th>含 义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>QT</td>
<td>指定项目中用到的所有模块，默认值为 core 和 gui，中间用 +=
符号连接。</td>
</tr>
<tr class="even">
<td>greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</td>
<td>如果 QT 版本大于 4（Qt5 或更高版本），则需要添加 widgets
模块，该模块包含所有控件类。</td>
</tr>
<tr class="odd">
<td>TARGET</td>
<td>指定程序成功运行后生成的可执行文件的名称，中间用 = 符号连接。</td>
</tr>
<tr class="even">
<td>TEMPLATE</td>
<td>指定如何运行当前程序，默认值为
app，表示当前程序是一个应用程序，可以直接编译、运行。常用的值还有
lib，表示将当前程序编译成库文件。</td>
</tr>
<tr class="odd">
<td>DEFINES</td>
<td>在程序中新定义一个指定的宏，比如 DEFINES += xxx，如同在程序中添加了
#define xxx 语句。</td>
</tr>
<tr class="even">
<td>SOURCES</td>
<td>指定项目中包含的所有 .cpp 源文件。</td>
</tr>
<tr class="odd">
<td>HEADERS</td>
<td>指定项目中包含的所有 .h 头文件。</td>
</tr>
<tr class="even">
<td>FORMS</td>
<td>指定项目中包含的 ui 文件。</td>
</tr>
<tr class="odd">
<td>INCLUDEPATH</td>
<td>指定头文件的存储路径，例如：INCLUDEPATH += /opt/ros/include</td>
</tr>
<tr class="even">
<td>CONFIG</td>
<td>经常对应的值有： release：以 release 模式编译程序； debug：以 debug
模式编译程序； warn_on：编译器输出尽可能多的警告； c++11：启动 C++11
标准支持。 例如 CONFIG += c++11。</td>
</tr>
</tbody>
</table>
<h3 id="打包">打包</h3>
<p>windeployqt 是 Qt 提供的 Windows 平台打包工具，它能找到
StuInfoFile.exe
可执行文件需要的所有动态链接库，并将它们拷贝到当前文件夹中。打包成功后将文件夹发给别人即可。</p>
<h2 id="常用类">常用类</h2>
<h2 id="组件总览">组件总览</h2>
<h2 id="qml">QML</h2>
<p>QML是⼀种描述⽤户界⾯的声明式语⾔。它将⽤户界⾯分解成⼀些更⼩的元素，这些元素能够结合成⼀个组件。QML语⾔描述了⽤户界⾯元素的形状和⾏为。⽤户界⾯能够使⽤JavaScript来提供修饰，或者增加更加复杂的逻辑。从这个⾓度来看它遵循HTML-JavaScript模式，但QML是被设计⽤来描述⽤户界⾯的，⽽不是⽂本⽂档。</p>
<h3 id="qml和c">QML和C++</h3>
<p>为了适应手机移动应用开发， Qt5 将 QML 脚本编程提到与传统 C++
部件编程相同的高度，力推 QML 界面编程，当然 QML
主要用于手机移动应用程序。 QML
包含大量使用手机移动设备的功能模块，比如基本部件（QtQuick 模块）、GPS
定位、渲染特效、蓝牙、NFC、WebkKit 等等。QML 类似于网页设计的
HTML，是一种标记语言，我们可以借助 CSS 对它进行美化，也可以借助 <a
href="http://c.biancheng.net/js/">JavaScript</a> 进行交互。有 Web
开发经验的读者学习 QML 将非常轻松。</p>
<p>使用 QML 开发界面主要有以下几个优点：</p>
<ul>
<li>QML 非常灵活，可以做出非常炫酷的效果，例如
QQ、360、迅雷等都不在话下。</li>
<li>QML
是标记语言，见名知意，非常容易编写和阅读，大大提高了开发和维护效率。</li>
<li>QML 界面简洁大气，有很多动画，适合移动端。</li>
<li>不同平台下的 QML
使用相同的渲染机制，界面效果一致，不会随操作系统的不同而变化。</li>
</ul>
<h2 id="参考">参考</h2>
<ol type="1">
<li><a
href="http://c.biancheng.net/view/1792.html">Qt教程|C语言中文网</a></li>
<li><a href="http://qmlbook.github.io/indxex.html">QmlBook</a></li>
<li><a href="https://doc.qt.io/">doc.qt.io</a></li>
</ol>
]]></content>
      <categories>
        <category>GUI</category>
        <category>QT</category>
      </categories>
      <tags>
        <tag>GUI</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-Next主题教程</title>
    <url>/web-site-article/2022/11/23/documents/hexo-next/</url>
    <content><![CDATA[<h2 id="配置文件">配置文件</h2>
<blockquote>
<p>数学公式</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Math Formulas Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Default (false) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to true, it will load mathjax / katex script EVERY PAGE.</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="添加分类和标签">添加分类和标签</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<h3 id="置顶文章">置顶文章</h3>
<p>hexo-generator-index是官方默认的博客文章排序插件，在我们安装hexo时就存在该插件了，hexo博客正常运行离不开该插件。
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure></p>
<h2 id="参考">参考</h2>
<ol type="1">
<li><a
href="https://blog.csdn.net/u011240016/article/details/79422462">hexo之next主题添加分类</a></li>
<li><a
href="https://blog.csdn.net/weixin_48927364/article/details/123295436">【Hexo】nexT主题使用攻略基础——添加分类、标签及关于</a></li>
<li><a
href="https://dingxiufeng.cn/index.php/archives/59/">hexo+next文章置顶+置顶标签</a></li>
</ol>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>vim简易教程</title>
    <url>/web-site-article/2022/11/23/other/vim%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><span class="math inline">\(a=b+c\)</span></p>
<h2 id="参考">参考</h2>
<ol type="1">
<li><a href="https://vimcdoc.sourceforge.net/">Vimcdoc PDF</a></li>
<li><a href="https://yianwillis.github.io/vimcdoc/doc/usr_toc.html">VIM
用户手册 - by Bram Moolenaar</a></li>
</ol>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>工具</tag>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo入门指南</title>
    <url>/web-site-article/2022/11/23/documents/hexo%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="快速开始">快速开始</h2>
<h2 id="hexo基本原理">hexo基本原理</h2>
<h2 id="写作流程">写作流程</h2>
<h2 id="插件推荐">插件推荐</h2>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 46%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">名称</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">使用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">hexo-admin</td>
<td
style="text-align: center;">给hexo一个简易的可视化后台来管理文章</td>
<td style="text-align: center;">启动服务后在路径后输入/admin即可</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-plugin详解</title>
    <url>/web-site-article/2022/11/23/documents/hexo-plugin/</url>
    <content><![CDATA[
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建</title>
    <url>/web-site-article/2022/11/22/documents/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="博客">博客</h2>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> hexo<span class="literal">-cli</span> <span class="comment">#安装脚手架</span></span><br><span class="line">hexo init [<span class="type">folder</span>] <span class="comment"># 初始化项目</span></span><br><span class="line">npm install <span class="literal">--save</span> hexo<span class="literal">-admin</span> <span class="comment"># 安装hexo-admin插件来管理文章</span></span><br><span class="line">npm install <span class="literal">-S</span> hexo<span class="literal">-theme-icarus</span> hexo<span class="literal">-renderer-inferno</span> <span class="comment"># 安装icarus主题</span></span><br><span class="line">hexo config theme icarus <span class="comment">#切换主题</span></span><br><span class="line">npm install hexo<span class="literal">-deployer-git</span> <span class="literal">--save</span> <span class="comment"># 安装Github Pages一键部署</span></span><br><span class="line">ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa <span class="literal">-C</span> <span class="string">&quot;youremail@example.com&quot;</span> <span class="comment">#添加ssh</span></span><br><span class="line"><span class="built_in">cat</span>  C:\Users\abott/.ssh/id_rsa.pub <span class="comment">#参考ssh</span></span><br><span class="line">ssh <span class="literal">-T</span> git@github.com <span class="comment">#验证是否成功</span></span><br></pre></td></tr></table></figure>
<h2 id="命令简单描述">命令简单描述</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new --path ../about &quot;关于我&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/abottleofmilk/&lt;username&gt;.github.io</span><br><span class="line">  branch: gh-pages</span><br><span class="line">  token: Personal access tokens (classic)</span><br></pre></td></tr></table></figure>
<h2 id="git-github">Git &amp; GitHub</h2>
<h3 id="or-create-a-new-repository-on-the-command-line">…or create a new
repository on the command line</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;# abottleofmilk.github.io&quot; &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin git@github.com:abottleofmilk/abottleofmilk.github.io.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<h3 id="or-push-an-existing-repository-from-the-command-line">…or push
an existing repository from the command line</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:abottleofmilk/abottleofmilk.github.io.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ol type="1">
<li><a
href="https://ppoffice.github.io/hexo-theme-icarus/uncategorized/icarus%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">hexo-theme-icarus</a></li>
<li><a
href="https://blog.csdn.net/weixin_45149481/article/details/116609116">hexo搭建博客shoka主题报错：
Function yaml.safeLoad is removed in js-yaml 4. Use yaml.load instead,
which is n_宁理大神1996的博客-CSDN博客</a></li>
<li><a href="https://jaredforsyth.com/hexo-admin/">hexo-admin</a></li>
<li><a href="https://hexo.io/zh-cn/docs/">hexo-docs</a></li>
<li><a
href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a></li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>文章</tag>
      </tags>
  </entry>
</search>
